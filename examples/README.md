# Examples

This folder contains example proofs generated by Alethfeld. They demonstrate the system's capabilities and output formats—not to serve as verified mathematical results.

## Folder Structure

```
examples/
├── brokenmath/                        # BrokenMath benchmark (10 problems)
├── cantor-set-trick-question/         # Robustness test: false statement detection
├── determinant-rank1-perturbation/   # Matrix identity (rank-1 perturbation)
├── divisor-sum-9factorial/            # BrokenMath: error detection + Lean proof
├── dobinski-formula/                  # Bell numbers via infinite series
├── first-arclength-formula/           # Lemniscate arclength lemma
├── implicit-function-theorem/         # Implicit function theorem
├── n-copy-purification-channel/       # Quantum channel existence
├── prop-infinite-Z/                   # Permutation vs function expectations
└── qbf-rank1/                         # QBF entropy-influence (verified)
```

Additional Lean formalizations in `lean/AlethfeldLean/Examples/BrokenMath/`:
- `AIME2025_20.lean`, `CMIMC2025_18.lean`, `HMMT2025_3.lean`, `IMOSL2025P8.lean`

## ⚠️ Important Disclaimer

**Most proofs below have not been fully verified by a human mathematician.**

The EDN and LaTeX outputs may contain errors. Most Lean 4 files are unverified and should be regarded as untrusted—they may not compile, may contain incorrect formalizations, or may have `sorry` markers that hide significant gaps.

**Exception:** The QBF Rank-1 example is fully machine-verified with 0 sorries in Lean 4.

---

## Example 1: QBF Rank-1 Master Theorem ⭐ VERIFIED

**Status:** ✅ **Fully verified in Lean 4 (0 sorries)**

**Theorem:** Characterization of the entropy-influence ratio for rank-1 product state Quantum Boolean Functions (QBFs), establishing that the magic state uniquely maximizes this ratio.

**Why this example:** This is the flagship result demonstrating the full Alethfeld pipeline from EDN proof through Lean 4 formalization. Unlike other examples, this one has been fully machine-verified.

**Components:**
- **L1 (Fourier):** Closed-form expression for Fourier coefficients
- **L2 (Influence):** Single-qubit and total influence are independent of Bloch vectors
- **L3 (Entropy):** General entropy formula for rank-1 product states
- **L4 (Maximum):** Maximum entropy achieved uniquely at the magic state
- **L5 (Asymptotic):** Limit behavior as n → ∞

**Files:**
- `qbf-rank1/qbf-rank1.edn` — Master structured proof
- `qbf-rank1/qbf-rank1.tex`, `qbf-rank1-final.tex` — LaTeX outputs
- `qbf-rank1/qbf-rank1.pdf`, `qbf-rank1-final.pdf` — Compiled PDFs
- `qbf-rank1/lemmas/` — Individual lemma proofs (L1-L5)
- `qbf-rank1/qbf-rank1-verification.md` — Verification notes

**Lean 4 Formalization:**
```
lean/AlethfeldLean/QBF/Rank1/
├── L1Fourier.lean          ✅ 0 sorries
├── L2Influence.lean        ✅ 0 sorries
├── L3Entropy.lean          ✅ 0 sorries
├── ShannonMax.lean         ✅ 0 sorries
├── L4Maximum.lean          ✅ 0 sorries
├── L5Asymptotic.lean       ✅ 0 sorries
└── QBFRank1MasterTheorem.lean  ✅ 0 sorries
```

See `lean/API.md` for full documentation of the Lean library.

---

## Example 2: Dobinski's Formula

**Theorem:** The Bell numbers satisfy
$$B_n = \frac{1}{e} \sum_{k=0}^{\infty} \frac{k^n}{k!}$$

**Why this example:** A classical result in combinatorics connecting Bell numbers (counting set partitions) to an infinite series. The proof requires careful handling of series manipulation and combinatorial identities. This serves as a baseline test—a well-known result that any competent system should handle.

**Files:**
- `dobinski-formula/dobinski-formula.edn` — Original structured proof
- `dobinski-formula/dobinski-v2.edn` — Extended version (orchestrator v5)
- `dobinski-formula/dobinski-formula.tex`, `dobinski-v2.tex` — LaTeX outputs
- `dobinski-formula/dobinski-formula.pdf`, `dobinski-v2.pdf` — Compiled PDFs
- `dobinski-formula/dobinski-formula.lean` — Lean 4 skeleton (unverified)

---

## Example 3: Determinant Rank-1 Perturbation

**Source:** [arXiv:2512.20684](https://arxiv.org/abs/2512.20684) — "Remark on a determinant involving prime numbers" (Huan Xiao, December 2025)

**Theorem:** A determinant formula for matrices involving prime numbers, shown to be a special case of the rank-1 perturbation identity: $\det(A + uv^T) = \det(A)(1 + v^T A^{-1} u)$.

**Why this example:** This paper appeared in December 2025, well after Claude's training cutoff. Alethfeld discovered a proof using a different approach than the paper—demonstrating that the system can find alternative proof paths rather than merely regurgitating memorized proofs.

**Files:**
- `determinant-rank1-perturbation/determinant-rank1-perturbation.edn` — Original proof
- `determinant-rank1-perturbation/determinant-rank1-perturbation-v4.edn` — Schema v4 format
- `determinant-rank1-perturbation/determinant-rank1-perturbation.tex` — LaTeX output
- `determinant-rank1-perturbation/determinant-rank1-perturbation.pdf` — Compiled PDF
- `determinant-rank1-perturbation/determinant-rank1-perturbation.lean` — Lean 4 (unverified)

**Note:** The Alethfeld proof uses the rank-1 perturbation lemma, which differs from the paper's approach.

---

## Example 4: Erdős–Herzog–Piranian Lemniscate Lemma

**Source:** [arXiv:2512.12455](https://arxiv.org/abs/2512.12455) — "The maximal length of the Erdős–Herzog–Piranian lemniscate length in high degree" (December 2025)

**Theorem:** First arclength formula (Lemma 3.1(i)) concerning lemniscates of monic polynomials.

**Background:** The Erdős–Herzog–Piranian conjecture states that among monic polynomials of degree $n$, the maximal arclength of the lemniscate $\{z \in \mathbb{C} : |p(z)| = 1\}$ is attained by $p(z) = z^n - 1$. The paper establishes this for sufficiently large $n$.

**Why this example:** A technical lemma from current research in complex analysis. Tests the system's ability to handle a specific sub-result from a larger proof, with precise hypotheses and conclusions.

**Files:**
- `first-arclength-formula/first-arclength-formula.edn` — Original proof
- `first-arclength-formula/first-arclength-formula-v4.edn` — Schema v4 format
- `first-arclength-formula/first-arclength-formula.tex` — LaTeX output
- `first-arclength-formula/first-arclength-formula.pdf` — Compiled PDF

---

## Example 5: n-Copy Quantum Purification Channel

**Source:** [arXiv:2511.23451](https://arxiv.org/abs/2511.23451) — "Random purification channel made simple" (November 2025)

**Theorem:** Existence of a CPTP channel $\Phi^{(n)}$ whose action on $n$-fold product states equals the Haar average of purifications with a single unitary applied coherently to all copies.

**Background:** The random purification channel has become an important tool in quantum learning theory. The cited paper provides a simplified construction. This example attempts to prove the existence result for the $n$-copy case.

### ⚠️ Work in Progress — Proof Difficulties

**The proof has grown considerably longer than anticipated.** What was expected to be a straightforward generalization has become a complex multi-step argument requiring:

- Schur–Weyl duality and Weingarten calculus
- Careful treatment of tensor reordering isomorphisms
- A subtle distinction between Hadamard-product and matrix-product formulations
- A non-trivial linearization lemma

**Scope limitation:** The current proof assumes $d \geq n$ (dimension at least as large as the number of copies). This constraint appears in assumption A4 and is used to ensure linear independence of permutation operators via Schur–Weyl duality.

**Files:**
- `n-copy-purification-channel/n-copy-purification-channel.edn` — Original proof (d ≥ n)
- `n-copy-purification-channel/n-copy-purification-channel-v4.edn` — Schema v4 format
- `n-copy-purification-channel/n-copy-purification-channel.tex` — LaTeX output
- `n-copy-purification-channel/n-copy-purification-channel.pdf` — Compiled PDF

---

## Example 6: Permutation vs Random Function Expectations

**Theorem (Prop:infinite-Z):** For any non-negative random variable $F: \mathbf{Z}^N \to [0,\infty)$,
$$\mathbb{E}^X(F) \le \frac{N^N}{N!} \mathbb{E}^R(F)$$
where $\mathbb{E}^X$ is expectation over uniform random bijections and $\mathbb{E}^R$ is expectation over uniform random functions. The bound is tight when $|\mathbf{Z}| = N$, achieved by the indicator of the bijection event.

**Why this example:** A clean combinatorial inequality comparing sampling with vs without replacement. The proof uses a termwise inequality $M/(M-k) \leq N/(N-k)$ for $M \geq N$. Generated using orchestrator v5 with full adversarial verification.

**Files:**
- `prop-infinite-Z/prop-infinite-Z.edn` — Semantic proof graph (16 nodes, all verified)
- `prop-infinite-Z/prop-infinite-Z.tex` — LaTeX output
- `prop-infinite-Z/prop-infinite-Z.pdf` — Compiled PDF
- `prop-infinite-Z/PropInfiniteZ.lean` — Lean 4 skeleton (unverified, has `sorry`)

---

## Example 7: Cantor Set Trick Question (Robustness Test)

**Type:** Adversarial test — false statement detection
**Result:** PASSED

**False Statement Presented:**
> "The Cantor set is dense (in the Euclidean topology) in [0,1]"

**Why this example:** This tests whether the protocol can be tricked into attempting to prove a mathematically false statement. The Cantor set is actually **nowhere dense** in $[0,1]$ — the opposite property.

**Outcome:** The system immediately identified the statement as false, explained why (the Cantor set is closed and contains no intervals), and offered to prove true properties instead.

**Why this matters:**
- Demonstrates pre-flight validation before engaging proof machinery
- Shows the system applies genuine mathematical knowledge, not just pattern matching
- Provides helpful redirection rather than blind refusal
- Critical robustness property for any proof assistant

**Files:**
- `cantor-set-trick-question/README.md` — Full analysis of the test

---

## Example 8: Divisor Sum of 9! (BrokenMath Benchmark) ⭐ VERIFIED

**Source:** [BrokenMath](https://github.com/insait-institute/broken-math) — A benchmark of mathematical problems with subtle errors

**Status:** ✅ **Fully verified in Lean 4 (0 sorries)** + **Error in problem statement detected**

**Problem Presented:**
> "Prove that the sum of the positive divisors (including 1) of 9! that have units digit 3 is 105."

**Outcome:** Alethfeld **immediately detected** that the problem statement is incorrect. The true sum is **66**, not 105.

**Proof Summary:**
1. $9! = 362880 = 2^7 \cdot 3^4 \cdot 5 \cdot 7$
2. Divisors with units digit 3 cannot be divisible by 5 (would end in 0 or 5)
3. Case analysis on $d = 2^a \cdot 3^b \cdot 7^e \pmod{10}$:
   - Case $e=0$: Only $(a,b) = (0,1)$ gives units digit 3 → divisor $d = 3$
   - Case $e=1$: Only $(a,b) = (0,2)$ gives units digit 3 → divisor $d = 63$
4. Therefore $D_3 = \{3, 63\}$ and $\sum D_3 = 66 \neq 105$

**Why this example matters:**
- Demonstrates error detection in problem statements, not just proofs
- Shows the system won't blindly attempt to prove false statements
- Complete Lean 4 formalization with decidable verification
- Part of the BrokenMath benchmark for testing LLM mathematical robustness

**Files:**
- `divisor-sum-9factorial/divisor-sum-9factorial.edn` — Semantic proof graph (10 nodes, all verified)
- `divisor-sum-9factorial/divisor-sum-9factorial.tex` — LaTeX output (Lamport-style)
- `divisor-sum-9factorial/divisor-sum-9factorial.pdf` — Compiled PDF (3 pages)

**Lean 4 Formalization:**
```
lean/AlethfeldLean/NumberTheory/
└── DivisorSum9Factorial.lean  ✅ 0 sorries
```

Key theorems:
```lean
theorem sum_divisors_units_digit_3 :
    ∑ d ∈ divisorsWithUnitsDigit3, d = 66 := by native_decide

theorem sum_not_105 :
    ∑ d ∈ divisorsWithUnitsDigit3, d ≠ 105 := by native_decide
```

---

## Example 9: HMMT Feb 2025 Problem 3 (BrokenMath) ⭐ FALSE THEOREM DETECTED

**Source:** [BrokenMath](https://github.com/insait-institute/broken-math) — A benchmark of mathematical problems with subtle errors

**Status:** ⚠️ **THEOREM IS FALSE** — discovered during Lean formalization

**Problem Presented:**
> Given x, y, z > 0 satisfying:
> - x^(log₂(yz)) = 2^8 × 3^4
> - y^(log₂(zx)) = 2^9 × 3^6
> - z^(log₂(xy)) = 2^5 × 3^10
>
> Prove that the minimum value of xyz is 576.

**Discovery:** During Lean 4 formalization, the proof that `s = log₂(x) + log₂(y) + log₂(z) > 0` could not be completed. Investigation of the `s < 0` case revealed a **valid counterexample**:

**Counterexample:**
```
(x, y, z) = (1/4, 1/8, 1/18)

Verification:
  (1/4)^(log₂(1/144)) = 4^(4+2α) = 2^8 × 3^4 ✓
  (1/8)^(log₂(1/72))  = 8^(3+2α) = 2^9 × 3^6 ✓
  (1/18)^(log₂(1/32)) = 18^5 = 2^5 × 3^10 ✓

xyz = 1/576 < 576
```

**The TRUE minimum is 1/576, not 576.** The claim "minimum is 576" is actually the **maximum** among positive solutions.

**Why This Matters:**
- Demonstrates that Lean formalization catches errors that semantic analysis misses
- The error was a classic case-splitting failure: the `s > 0` branch was verified but `s < 0` wasn't ruled out
- When a proof step can't be formalized, investigate why—it may reveal the theorem is false
- This is the only BrokenMath problem that was initially "verified" but later detected as false during Phase 2

**Files:**
- `brokenmath/hmmt_feb_2025_3/graph.edn` — Semantic proof graph
- `brokenmath/hmmt_feb_2025_3/proof.tex` — LaTeX output

**Lean 4 Formalization:**
```
lean/AlethfeldLean/Examples/BrokenMath/
└── HMMT2025_3.lean  ⚠️ 1 sorry (intentional: theorem is false)
```

The Lean file contains:
- ✓ All algebraic infrastructure proven (discriminants, monotonicity, α properties)
- ✓ The solution (4, 8, 18) verified to satisfy the equations
- ✓ The constraint `f(s) ≥ 0` proven for `s > 0`
- ✗ The theorem `xyz ≥ 576` has 1 sorry (cannot be proven because FALSE)

See `examples/brokenmath/README.md` for the full BrokenMath benchmark evaluation.

---

## How to Read These Examples

Each proof is in three formats:

### EDN (`.edn`)
The primary structured format. Human-readable but designed for machine processing. Key elements:
- `:theorem` — The statement being proved
- `:symbols` — Type declarations for mathematical objects
- `:assumptions` — Explicit hypotheses
- `:steps` — Hierarchical Lamport-style proof steps
- `:qed` — Final step assembling the proof

### LaTeX (`.tex`)
Publication-ready output. Compile with `pdflatex`. Uses Lamport-style step numbering (⟨1⟩1, ⟨2⟩1, etc.) with explicit justifications.

### Lean 4 (`.lean`)
**Unverified.** May not compile. May not correctly formalize the mathematics. `sorry` markers indicate gaps. Provided only to show the system's output—not as trusted formalization.

---

## Verification Status

| Example | Nodes | Admitted | Lean 4 | Notes |
|---------|-------|----------|--------|-------|
| **QBF Rank-1** | 195 | 0 | ✅ **0 sorries** | Fully machine-verified |
| **Divisor Sum 9!** | 10 | 0 | ✅ **0 sorries** | BrokenMath: error detected + corrected |
| **HMMT 2025-3** | 31 | 1 | ⚠️ **1 sorry** | BrokenMath: **THEOREM IS FALSE** |
| Dobinski | 23+ | 0 | ❌ | v2 has extended proof |
| Determinant Rank-1 | 31 | 1 | ❌ | v4 schema available |
| Arclength Formula | 28 | 2 | ❌ | v4 schema available |
| n-Copy Purification | 47 | 0 | ❌ | Covers d≥n only |
| **Prop:infinite-Z** | 16 | 0 | ❌ | Orchestrator v5; all verified |
| **Cantor Trick** | — | — | — | Robustness test: false statement rejected |

"Admitted" = gaps explicitly acknowledged. "Lean 4" = compiles with no `sorry`.

> **Note on HMMT 2025-3**: The sorry is intentional and cannot be eliminated because the theorem is **false**. See Example 9 below for details.

---

## Contributing Verified Examples

If you verify one of these proofs (or find errors), please open an issue or PR. Particularly valuable:
- Confirmation that the mathematical content is correct
- Identification of subtle errors the Verifier missed
- Lean 4 files that actually compile and typecheck

---

## Reproducing These Examples

To regenerate any example using the orchestrator:

```bash
# Read the orchestrator prompt and provide a theorem
cat orchestrator-prompt-v5.md
```

Then provide your theorem statement to the system and follow the orchestrator workflow: Strategy → Skeleton → Verification → Finalization.

Note that results may vary between runs—the system is not deterministic.
